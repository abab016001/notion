# Cache 快取

瀏覽器從本地快取取得資源
是利用瀏覽器的 <b>快取機制 ( Cache )</b> 來實現。
具體來說，
當第一次訪問某個網站時，瀏覽器會根據 HTTP 響應標頭：
* Cache-Control
* ETag
* Last-Modified
* ...等

決定是否將資源 ( 圖片、CSS、JavaScript等 )儲存在本地快取中。
當下次訪問瀏覽器時，優先至快取中加載而不是重新從伺服器下載。

這樣做可以提高頁面載入速度，減少伺服器負擔並減少網路流量。

## 主要機制包括：
### 1. Cache-Control
告訴瀏覽器該資源應該被快取多久
是否可從快取直接讀取，還是需要重新請求等。
* 例如：<code> Cache-Control: max-age=3600 </code>
表示資源在一小時內有效。

### 2. ETag
ETag 是資源的版本標示符，瀏覽器會將資源的 ETag 存儲在本地快取中。
下次請求時會將此 ETag 發送給伺服器，伺服器則會根據這個 ETag 來判斷資源是否有更新。
如果沒有更新，會回傳 <code>304 Not Modified</code> 狀態，讓瀏覽器直去使用本地快取。

### 3. Last-Modified
標記資源的最後修改時間。
瀏覽器下次請求時會將此時間發送給伺服器，伺服器如檢測到資源未更動，就會返回 <code>304 Not Modified</code> 狀態。

### 4. Expires
設定資源過期的時間，過期後需要重新加載資源。

## 快取流程概述：
1. 用戶首次請求資源，瀏覽器向伺服器發送請求，並接收帶有快取標頭的響應。
2. 資源被儲存到瀏覽器的快取中，並標註快取時間或版本。
3. 下次請求相同資源時，瀏覽器會檢查是否有有效的快取，
如果有，則從本地加載資源；如果快取過期或無效，則向伺服器發送請求，伺服器檢查資源是否更新。

## 快取存放位置：
瀏覽器的快取資料通常會存在本地的磁碟上，包括 C槽 或其他硬碟分區中。
不同瀏覽器會將快取資料存儲在各自的指定位置，並由瀏覽器自動管理。
### 1. Google Chrome：
 * 在 Windows 上，Chrome 的快取通常位於：
 <code>C:\User\[Your Username]\AppData\Local\Google\Chrome\User Data\Default\Cache</code>

### 2. Mozilla Firefox：
 * 在 Windows 上，Firefox 的快取通常位於：
 <code>C:\Users\[Your Username]\AppData\Local\Mozilla\Firefox\Profiles\[Profile Name]\cache2</code>
 
### 3. Microsoft Edge：
 * Edge的快取位置類似於Chrome，通常位於：
 <code>C:\Users\[Your Username]\AppData\Local\Microsoft\Edge\User Data\Default\Cache</code>

### 4. Safari（對於Mac）：
 * 在Mac上，Safari的快取會存儲在：
 <code>~/Library/Caches/com.apple.Safari</code>

## 快取資料的管理
* <b>大小限制：</b>
大部分瀏覽器都會限制快取資料夾的大小，當快取達到設定的大小上限時，瀏覽器會自動刪除舊的資源以騰出空間。
* <b>過期控制：</b>
快取資料不會無限期保留在本地。
根據網頁或資源的快取控制標頭 ( 如 <code>Cache-Control</code> 、 <code>Expires</code> 等 ) ，
瀏覽器會定期檢查和更新本地快取。

## 快取的管理
* 用戶可以手動清除瀏覽器快取資源
* 自動管理：大部分情況下，瀏覽器會自動處理快取的儲存和過期，確保用戶可以得到最新的網頁內容。

## 快取管理細節
在了解快取管理前，必須先知道當初安裝瀏覽器時，瀏覽器對本地做了什麼
>   當安裝瀏覽器時
    瀏覽器會在電腦指定位置生成存放 cache 的資料夾目錄作為 <b>快取存放位置</b>
    並安裝```LevelDB```輕量級嵌入式數據庫來管理 cache 資料。

>   之後在對伺服器發出請求前會先以資源 URL查調```LevelDB```，取得ETag、 過期時間...等資訊並對照取得資源元數據(hash值)。
又或者將自伺服器取得的資源以元數據的形式存入<b>快取存放位置</b>
並把元數據的基本資訊寫入```LevelDB```以供查詢。

------------------------------

之後當瀏覽器向伺服器發送請求 ( 例如.圖片A ) 時
<b>根據快取狀態，瀏覽器會有「三種可能行為」：</b>
* ① 快取命中 ( 有效 )
    如果快取裡的資源還沒過期，且符合快取策略 ( 例如```Cache-Control: max-age=3600``` )，<b>瀏覽器會直接本地資源，不發送請求給伺服器。</b>
    > ✅這叫做「強快取( Strong Cache )」。
    
    ➡️ 本地 cache 資料夾下會有瀏覽器專用的儲存與查調機制：
    * 瀏覽器並不會以純文字形式存儲索引，而是會將快取資料和相關的元數據（如 ETag、過期時間、資源 URL 等）存儲在特定格式的文件或數據庫( ```LevelDB```輕量級嵌入式數據庫 )中，這些檔案通常是二進位格式或專有格式。這些文件對用戶來說是不可讀的，瀏覽器會在內部處理這些資料結構。

    ➡️ 瀏覽器會根據資源的 URL 查找 ：
    * 快取裡有沒有這個資源？
    * 如果有，有沒有過期？
    * 有沒有附帶 ETag 或 Last-Modified？
        
* ② 快取命中但需要確認
    如果資源雖然在快取中，但過期了又或者有 ```no-cache``` 標頭，瀏覽器會發出「條件請求」，例如```If-None-Match``` 或 ```If-Modified-Since```。
    伺服器會：
    * 回 ```304 Not Modified``` → 用快取的內容。
    * 回 ```200 OK``` 和新內容 → 更新快取。
    > ✅這叫做「協商快取 ( Negotiated Cache ) 」。
        
    🧠 當伺服器收到帶有 If-None-Match 的請求時，流程是這樣：
    1. <b>伺服器取出目前自己那份「最新版本」的資源</b> 
        ( 例如.圖片A、CSS檔案等等 )。
    2. <b>伺服器重新「計算或讀取」這份資源的ETag：</b>
        * 如果是「內容哈希類型的ETag」，伺服器可能會重新用 hash function ( 像是 MD5、SHA ) <b>把資源內容算出一個哈希值</b>
        * 有些伺服器是「紀錄式的ETag」，在資源保存或更新時就把ETag存好，只是<b>讀出來對比</b>而已(更省事)。
    3. <b>伺服器把剛剛算出或取出的ETag和瀏覽器送來的```If-None-Match``` 比對。</b>
    4. <b>判斷結果：</b>
        * 一樣 ➔ 回 ```304 Not Modified```
        * 不一樣 ➔ 回 ```200 OK``` + 全新資源

* ③ 快取中沒有資源
    瀏覽器會發送「第一次請求」給伺服器，伺服器回完整內容 + ETag
    並將完整內容於<b>快取存放位置</b>存為元數據
    將ETag、過期時間、資源 URL ...等資料存入```LevelDB```以供查詢
    > ✅這種情況會建立快取紀錄，用於以後的請求。

------------------------------

是說，怎麼知道元數據過期了沒？
    
🧠 判斷快取是否過期的方式主要有兩種：

✅ 1. Cache-Control（最常見）
```https
Cache-Control: max-age=3600
意思是：「這份資源可以快取 3600 秒（= 1 小時）」
```
>   👇流程是這樣：

    瀏覽器收到這份資源時會記錄當下時間。

    然後會加上 max-age 去算「過期時間」。

    下次請求這個資源時，先看現在時間有沒有超過這個期限。

    🕒 如果超過 → 視為「過期」，進入協商快取階段（發送 ETag 等）

    🕒 沒超過 → 快取還有效，直接使用，不發請求！ 

✅ 2. Expires（舊方法）
另一種方式是伺服器直接指定一個過期的「日期時間」：

```https
Expires: Wed, 01 May 2025 12:00:00 GMT
意思是：「這個資源在 2025/5/1 中午以前都算有效。」
```
> 這方法比較老舊，容易受時間不準影響，現在大多數都用 Cache-Control。

------------------------------

🛠️ 伺服器將資源轉成 hash 是在哪一層做的？

簡單來說，是在「 <b>HTTP 應用層 (Application Layer) </b> 」做的事情。
* <b>不是TCP層、不是作業系統底層</b>
* 是伺服器軟體在處理 「 HTTP 請求 」 時，在 <b>應用邏輯階段</b>去執行的。

🛠️ 如果自己開發 HTTP server，要不要寫這段？
> ✅ 如果你希望支援「協商快取」功能，就必須自己寫這段！

也就是：
要自己設計一個機制，為資源生成 ETag（常見做法是用 Hash，例如 MD5、SHA-1、SHA-256）。
收到 ```If-None-Match``` 時，要自己比對 ETag。
決定要回 ```304``` 還是 ```200```。

🔥 真實例子
<b>Server 軟體</b> v.s. <b>產生ETag的方法</b>

> <b>Nginx</b>
通常是用檔案的 inode、mtime（修改時間）、size 組合成一個 ETag（所以不一定是純內容hash）

> <b>Apache</b>
可以設定成內容hash或是檔案屬性（檔案最後修改時間等等）

> <b>自製Server</b>
可以用 SHA256(資源內容) 來生成 ETag，自由控制

------------------------------

🧠 如果一個伺服器 <b>沒有支援 ETag（或者協商快取機制）</b>，會發生什麼事？

✅ 每次瀏覽器請求資源，都會是這樣：
* 不管本地快取有沒有。
* 伺服器都必須重新傳送完整的檔案。
* 比如一張5MB的圖片，每個用戶一打開就重新傳一次。

📈 問題會變成這樣：
>   <b>問題：</b> 頻寬被狂用
    <b>結果：</b> 伺服器流量爆炸（很快超出流量上限，或者收超高費用）

>   <b>問題：</b> CPU忙著處理IO
    <b>結果：</b> 每次都要從硬碟讀取檔案、傳輸，CPU/IO負擔大

>   <b>問題：</b> 伺服器回應變慢
    <b>結果：</b> 請求排隊，使用者體驗超爛，甚至逾時 timeout

>   <b>問題：</b> 多人同時來訪
    <b>結果：</b> 伺服器可能直接爆掉（Memory/IO不堪負荷）

🔥 超經典真實世界例子
*   有些小公司網站一開始沒設快取（也沒CDN），流量一多（比如新聞爆紅）
    → 直接當掉（伺服器 CPU 跟頻寬都滿載）。
*   大型網站（像Facebook、YouTube）超級重視快取，因為每一小段浪費的流量
    → 乘上全球幾億用戶，就是天文數字的費用跟效能壓力！  

🧠 <b>所以結論：</b>
> <b>沒有 ETag/快取支援 ➔ 資源重新傳 ➔ 浪費頻寬 ➔ 負荷增加 ➔ 伺服器變慢或掛掉！</b>
